# 1.Назначение проекта
Cравнить эффективность последовательной обработки (один поток), параллельной обработки (множество потоков) на примере поиска максимального элемента в массиве из 100 миллионов целых чисел.

# 2.Архитектура
Основные компоненты:
- Генерация данных - generateRandomElements()
- Поиск максимума - maximum()
- Параллельный поиск - maxChunks()
- Бенчмарк - main()
- Тесты - проверка корректности

# 3.Основные функции

1. Генерация случайных данных: func generateRandomElements(size int) []int
- Создаёт массив указанного размера
- Заполняет случайными целыми числами
 2. Последовательный поиск максимума: func maximum(data []int) int
- Проходит по массиву в одном потоке
- Возвращает максимальный элемент
 3. Параллельный поиск максимума: func maxChunks(data []int) int
- Разбивает массив на CHUNKS частей
- Каждую часть обрабатывает отдельный goroutine
- Синхронизирует доступ через mutex
- Находит максимум среди всех локальных максимумов

# 4.Параллельная обработка
Алгоритм:
1. Разделение данных: массив делится на 8 частей
2. Параллельная обработка: каждая часть обрабатывается в отдельной goroutine
3. Синхронизация: используется sync.WaitGroup и sync.Mutex
4. Сбор результатов: локальные максимумы собираются в общий слайс
5. Финальный поиск: находится максимум среди локальных максимумов

# 5.Синхронизация
Используемые примитивы:
- sync.WaitGroup - ожидание завершения всех goroutine
- sync.Mutex - безопасный доступ к общему ресурсу (results)

# 6.Преимущества подхода
1. Масштабируемость: легко изменить количество потоков
2. Эффективность: использование всех ядер CPU
3. Безопасность: правильная синхронизация
4. Измеримость: чёткое сравнение производительности

# 7.Технические детали
Используемые технологии:
- Goroutines - легковесные потоки Go
- Channels - не используются (вместо них mutex)
- sync - пакет для синхронизации
- math/rand - генерация случайных чисел
- testing/testify - фреймворк для тестирования
